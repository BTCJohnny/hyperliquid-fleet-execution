# System Architecture

## Overview

Hyperliquid Fleet Execution is a multi-threaded trading bot orchestrator that processes signals from a SQLite database and executes trades on Hyperliquid DEX. The system operates as the **execution layer** in a larger trading pipeline, consuming signals generated by an external ingestion system.

## System Components

### 1. Signal Processing Loop (Main Thread per Bot)

Each bot runs a dedicated signal processing loop that:
- Polls SQLite database every 2 seconds
- Filters signals by `bot_name` (must match configured bot ID)
- Processes signals with strict priority ordering
- Manages order placement and position sizing

**Priority Order:**
1. **Exit Signals** - Always processed first to prevent "ghost orders"
   - Cancel all open orders for the ticker (removes unfilled limit buys)
   - Market close the position
   - Validate API response before marking complete

2. **Entry Signals** - Only processed if no exits are pending
   - Calculate position size based on risk parameters
   - Apply leverage cap
   - Round price/size to Hyperliquid's precision requirements
   - Place limit entry + stop loss + take profit orders

### 2. Fill Monitor Loop (Background Thread per Bot)

Each bot runs a background thread that monitors fills and triggers reactive trading logic:
- Polls Hyperliquid `user_fills()` API every 10 seconds
- Detects when TP orders are filled
- Triggers breakeven stop loss adjustment when TP1 hits
- Tracks last processed fill timestamp to avoid duplicate processing

**Breakeven Logic:**
1. When TP1 fills, cancel original stop loss
2. Calculate remaining position size (75% if 4 TPs)
3. Place new SL at entry price (breakeven)
4. Update database with new SL order ID

### 3. Database Integration

**Database Location:** Configurable via signal parser (default: `/Users/johnny_main/Developer/data/signals/signals.db`)
**Mode:** WAL (Write-Ahead Logging) for concurrent read/write access
**Schema:** See docs/DATABASE_SCHEMA.md for full contract

**Signal Lifecycle:**
```
'pending' → (entry execution) → 'filled' → (TP/SL trigger) → 'executed'
'pending' → (exit execution) → 'executed'
           ↓ (if error)
        'failed' (with error notes)
```

### 4. Risk Management System

Position sizing is calculated using a risk-per-trade model:

**Formula:**
```
size = (equity * risk_per_trade) / abs(entry_price - stop_loss)
```

**Parameters:**
- `RISK_PER_TRADE` - % of equity to risk (default: 2%)
- `MAX_LEVERAGE` - Maximum allowed leverage (default: 1.0x, can be overridden per bot)
- `DEFAULT_SL_DIST` - Default stop loss distance if signal doesn't include one (default: 5%)
- `MAX_CONCURRENT_POSITIONS` - Maximum open positions per wallet (default: 3)

**Leverage Cap Enforcement:**
If calculated leverage exceeds `MAX_LEVERAGE`, the position size is automatically reduced:
```
if actual_leverage > max_leverage:
    size = size * (max_leverage / actual_leverage)
```

### 5. Dynamic Precision System

Hyperliquid has strict rejection rules for price and size decimals. The system uses metadata-driven precision:

**Size Rounding:**
- Uses `szDecimals` from Hyperliquid metadata (cached at initialization)
- Example: NEO=2 decimals, ETH=4 decimals

**Price Rounding:**
- Applies two rules: Max 5 significant figures, Max decimals = `6 - szDecimals`
- The stricter rule wins
- Prevents "Invalid Size" and "Too many decimals" rejections

### 6. Monthly Order ID Reset Handling

Hyperliquid resets order IDs on the 1st of each month. To prevent collisions when matching fills to signals, all queries include a 30-day time filter:

```sql
WHERE datetime(created_at) > datetime('now', '-30 days')
```

This ensures that:
- February fill (OID 123456) won't incorrectly match January signal with same OID
- Long-running positions are still tracked (30-day window is sufficient)

## Data Flow

```
External System:
┌─────────────────────────────────────────────────────────┐
│  Telegram Signal → Parser → signals.db (status='pending'│
└─────────────────────────────────────────────────────────┘
                            │
                            ▼
Internal System:
┌──────────────────────────────────────────────────────────────┐
│                      Fleet Runner                             │
│  ┌────────────────┐  ┌────────────────┐  ┌────────────────┐ │
│  │  Bot 1 (Alice) │  │  Bot 2 (Sent)  │  │ Bot 3 (Alpha)  │ │
│  ├────────────────┤  ├────────────────┤  ├────────────────┤ │
│  │ Signal Thread  │  │ Signal Thread  │  │ Signal Thread  │ │
│  │ Monitor Thread │  │ Monitor Thread │  │ Monitor Thread │ │
│  └────────────────┘  └────────────────┘  └────────────────┘ │
└──────────────────────────────────────────────────────────────┘
         │                     │                     │
         └─────────────────────┴─────────────────────┘
                               ▼
                      Hyperliquid API
                    (Order Placement & Fills)
```

## Threading Model

Each bot spawns **2 daemon threads**:
1. **Signal Processing Thread** - Named `{bot_id}-signal`, processes entry/exit signals
2. **Fill Monitor Thread** - Named `{bot_id}-monitor`, detects fills and triggers breakeven logic

**Thread Safety:**
- SQLite timeout: 10 seconds (handles write contention)
- Database locks managed by WAL mode
- Independent threads per bot (no shared state between bots)
- Each thread maintains its own database connection

**Main Thread:**
- Runs `launch_fleet()` in `fleet_runner.py`
- Spawns all bot threads
- Keeps alive with `while True: time.sleep(1)` loop
- Handles `KeyboardInterrupt` for clean shutdown

## Order ID Tracking

**Challenge:** Hyperliquid order IDs reset monthly, making it difficult to correlate fills with signals after month boundaries.

**Solution:** Store order IDs in database with 30-day time filter in all matching queries.

**Database Columns Added (2026-01-12):**
- `order_id_entry`, `order_id_sl`, `order_id_tp1-5` - Track Hyperliquid OIDs
- `entry_filled_at`, `tp1_filled_at-5` - Timestamp of fills
- `sl_moved_to_be` - Boolean flag indicating breakeven triggered
- `be_sl_order_id` - New SL order ID after breakeven

**Order ID Extraction:**
Hyperliquid API responses have nested structure:
```python
result['response']['data']['statuses'][0]['resting']['oid']  # Limit orders
result['response']['data']['statuses'][0]['filled']['oid']   # Market orders
```

## Fleet Configuration

Bots are configured in `FLEET_CONFIG` within `fleet_runner.py`:

```python
FLEET_CONFIG = [
    {
        "bot_id": "Apprentice Alchemist",
        "private_key": os.getenv("PRIVATE_KEY_ALCHEMIST"),
        "risk_per_trade": 0.02,
        # Uses .env defaults for leverage and stop distance
    },
    {
        "bot_id": "AlphaCryptoSignal",
        "private_key": os.getenv("PRIVATE_KEY_ALPHA"),
        "risk_per_trade": 0.02,
        "max_leverage": 20.0,  # OVERRIDE: Higher risk tolerance
        "default_sl_dist": 0.02  # 2% default stop
    }
]
```

**Bot Routing:**
- `bot_id` must match the `bot_name` column in signals database
- Signal parser populates `bot_name` based on Telegram channel source
- Each bot has its own wallet (private key) and can have custom risk parameters

## External Dependencies

### Python Packages
- `hyperliquid-python-sdk` - Official Hyperliquid API client
- `python-dotenv` - Environment variable management
- `pandas` - For PnL dashboard and analysis tools
- `tabulate` - CLI table formatting

### External Systems
- **Signal Ingestion:** [telegram_forwarder](https://github.com/BTCJohnny/telegram_forwarder)
  - Parses Telegram signals and populates database
  - Located at `/Users/johnny_main/Developer/projects/telegram_forwarder/`
- **Shared Database:** `/Users/johnny_main/Developer/data/signals/signals.db`
- **Logs Directory:** `/Users/johnny_main/Developer/data/logs/`

## Configuration Management

All sensitive configuration is via `.env` file:

```bash
# Wallet private keys (3 bots)
PRIVATE_KEY_SENTIENT=0x...
PRIVATE_KEY_ALCHEMIST=0x...
PRIVATE_KEY_ALPHA=0x...

# Risk parameters
RISK_PER_TRADE=0.02
MAX_LEVERAGE=1.0
DEFAULT_SL_DIST=0.05
MAX_CONCURRENT_POSITIONS=3

# Feature flags
ENABLE_BREAKEVEN_SL=True

# Network selection
IS_MAINNET=False
```

**Security:** `.env` is in `.gitignore` - never committed to version control.

## Monitoring and Observability

### Logging
- **Format:** `%(asctime)s - [%(threadName)s] - %(levelname)s - %(message)s`
- **Location:** `/Users/johnny_main/Developer/data/logs/fleet_activity.log`
- **Rotation:** Manual (use logrotate or similar)

### Admin Controls
CLI tool for fleet management:
```bash
python admin_controls.py "Apprentice Alchemist" STATUS
python admin_controls.py ALL POSITIONS
python admin_controls.py ALL ORDERS
python admin_controls.py ALL PAUSE
python admin_controls.py "Alpha" RESUME
```

### Emergency Controls
```bash
# Cancel all orders and close all positions
python nuke_account.py "AlphaCryptoSignal"  # Specific bot
python nuke_account.py ALL                   # All bots
```

### PnL Dashboard
```bash
python pnl_dashboard.py  # View profit/loss across all bots
```

See [MONITORING.md](MONITORING.md) for full observability guide.

## Error Handling

### Order Placement Failures
- Validate API response with `_check_order_status(result)`
- Mark signal as `'failed'` in database with error notes
- Log detailed error message with bot context
- Continue processing next signal (don't crash)

### Race Conditions
- **Ghost Orders:** Exit signals cancel orders BEFORE closing positions
- **Breakeven Timing:** Check position still exists before modifying SL
- **Concurrent Access:** SQLite WAL mode + 10-second timeout

### API Failures
- Retry logic: Not currently implemented (fire-and-forget model)
- Failed orders remain in `'pending'` status for manual review
- Admin controls allow manual intervention

## Performance Characteristics

### Polling Intervals
- **Signal Processing:** 2 seconds
- **Fill Monitoring:** 10 seconds

### Database Performance
- **WAL Mode:** Enables concurrent reads while writing
- **Connection Pooling:** Not used (each thread has own connection)
- **Query Performance:** Fast (<1ms for typical queries with proper indexing)

### API Rate Limits
- Hyperliquid has rate limits (not explicitly documented)
- System respects limits via polling intervals
- No burst requests (sequential order placement)

## Deployment

### Development (Current)
- Run manually: `python fleet_runner.py`
- Stop with `Ctrl+C`

### Production (Recommended)
- Use systemd (Linux) or launchd (macOS) for auto-restart
- Configure log rotation
- Set up monitoring alerts
- Enable database backups

Example launchd plist:
```xml
<plist version="1.0">
<dict>
    <key>Label</key>
    <string>com.hyperliquid.fleet</string>
    <key>ProgramArguments</key>
    <array>
        <string>/usr/bin/python3</string>
        <string>/path/to/fleet_runner.py</string>
    </array>
    <key>RunAtLoad</key>
    <true/>
    <key>KeepAlive</key>
    <true/>
</dict>
</plist>
```

## Future Enhancements

### Potential Improvements
1. **Trailing Stop Loss** - Extend fill monitor to implement trailing stops
2. **Retry Logic** - Add exponential backoff for failed orders
3. **WebSocket Integration** - Replace polling with WebSocket feeds for lower latency
4. **Advanced Risk Management** - Portfolio-level risk (not just per-trade)
5. **Multi-Exchange Support** - Abstract exchange interface for other DEXs
6. **Backtesting Framework** - Replay signals against historical data

### Architecture Evolution
- Consider migrating to Redis for signal queue (better performance at scale)
- Implement gRPC for inter-service communication
- Add metrics collection (Prometheus/Grafana)
- Containerize with Docker for easier deployment

## Code Organization

```
hyper_v1/
├── fleet_runner.py              # Main entry point, bot orchestration
├── hyperliquid_top_gun.py       # Core execution engine class
├── admin_controls.py            # CLI management interface
├── nuke_account.py              # Emergency position closer
├── pnl_dashboard.py             # PnL reporting tool
├── enable_wal.py                # SQLite WAL mode setup
├── nuke_database.py             # Database cleanup utility
├── reset_id_counter.py          # Utility for ID counter
├── test/                        # Test suite
│   ├── connection_test.py       # Fleet connectivity check
│   ├── test_db_integration.py   # DB integration tests
│   ├── test_rejection.py        # Order rejection testing
│   └── [more tests...]
├── .env                         # Configuration (NOT in git)
├── .env.example                 # Template
├── requirements.txt             # Python dependencies
├── CLAUDE.md                    # AI assistant guidance
├── MONITORING.md                # Observability guide
└── ARCHITECTURE.md              # This file
```

## Key Classes and Methods

### HyperLiquidTopGun
**Purpose:** Core execution engine for a single bot

**Key Methods:**
- `run_loop()` - Main signal processing loop (runs in thread)
- `run_fill_monitor()` - Fill monitoring loop (runs in thread)
- `_process_entry_signal()` - Handle entry signal execution
- `_process_exit_signal()` - Handle exit signal execution
- `_process_fill()` - Process a single fill event
- `_move_sl_to_breakeven()` - Implement breakeven logic
- `_extract_order_id()` - Extract OID from API response
- `round_px()` - Apply price rounding rules
- `get_token_sz_decimals()` - Get size decimals for ticker

**Constructor Parameters:**
- `bot_id` - Bot identifier (must match database `bot_name`)
- `private_key` - Wallet private key
- `risk_per_trade` - Risk percentage (optional, defaults to .env)
- `max_leverage` - Leverage cap (optional, defaults to .env)
- `default_sl_dist` - Default SL distance (optional, defaults to .env)

## Integration Points

### Input: Signal Ingestion
- **Source:** SQLite database populated by [telegram_forwarder](https://github.com/BTCJohnny/telegram_forwarder)
- **Table:** `signals` with `status='pending'`
- **Filter:** `bot_name` matches configured bot ID
- **Contract:** See docs/DATABASE_SCHEMA.md

### Output: Hyperliquid API
- **Orders:** Place via `exchange.order()` with `reduce_only=True` for closes
- **Cancels:** Cancel via `exchange.cancel(ticker, oid)`
- **Fills:** Poll via `info.user_fills(address)`
- **Positions:** Query via `info.user_state(address)`

### Control: Admin Interface
- **Database:** `bot_controls` table for PAUSE/RESUME/CLOSE_ALL commands
- **CLI:** `admin_controls.py` writes commands, bots poll and execute

## Glossary

- **TP** - Take Profit (target price to close position for profit)
- **SL** - Stop Loss (price to close position to limit loss)
- **BE** - Breakeven (moving SL to entry price after TP1 hits)
- **OID** - Order ID (Hyperliquid's internal order identifier)
- **WAL** - Write-Ahead Logging (SQLite concurrency mode)
- **Ghost Order** - Unfilled limit order that remains active after position close
- **Fire-and-Forget** - Order placed without waiting for fill confirmation
- **Daemon Thread** - Background thread that exits when main thread exits
